"""Functions to run a VQE."""
from typing import Dict, Sequence

import numpy

import openfermion
import cirq


def circuit_state_fidelity(parameters: Sequence,
                           circuit: cirq.Circuit,
                           parameters_dict: Dict,
                           target_states: numpy.ndarray,
                           simulator: cirq.Simulator) -> float:
    """
    Returns fidelity to target_states of the state produced by the circuit.

    If target_states contain multiple orthogonal states (as column vectors),
    returns the fidelity to the subspace generated by them.

    Args:
        parameters (List): parameterst to update the circuit.
        circuit (cirq.Circuit): Circuit object to prepare state.
        parameters_dict (Dict): Dictionary of parameters needed to resolve the
            circuit.
        target_states (numpy.ndarray): Array representating the target
            state(s), with which the overlap is computed. If target_states is a
            two-dimensional ndarray, the column vectors are interpreted as
            (orthonormal) basis vectors of the target subspace.
    """
    if len(parameters) != len(parameters_dict):
        raise ValueError('Number of parameters and dictionary do not match.')

    if not isinstance(target_states, numpy.ndarray):
        raise TypeError(
            '`target_states` should be a numpy.ndarray, not {}'
            .format(type(target_states)))
    if len(target_states.shape) == 1:
        target_states = numpy.reshape(target_states, (-1, 1))
    if len(target_states.shape) != 2:
        raise TypeError(
            '`target_states` should be a one- or two-dimensional np.array')

    for val, key in zip(parameters, parameters_dict.keys()):
        parameters_dict[key] = val

    simulated_circuit = simulator.simulate(
        cirq.resolve_parameters(circuit,
                                cirq.ParamResolver(parameters_dict)))

    fidelity = sum(
        numpy.abs(numpy.dot(simulated_circuit.final_state.conj(), state))**2
        for state in target_states.T)

    return fidelity


def circuit_state_expval(parameters: Sequence,
                         circuit: cirq.Circuit,
                         parameters_dict: Dict,
                         observable: openfermion.QubitOperator,
                         simulator: cirq.Simulator) -> float:
    """
    Returns observable expectation value on the state produced by the circuit.

    The circuit is resolved using the parameters values given in ´parameters´,
    with the names in `parameters_dict`.

    Args:
        circuit: Circuit object to prepare state.
        parameters: parameterst to update the circuit.
        parameters_dict: Dictionary of parameters.
        observable: observable to be measured as a qubit operator.
    """
    if len(parameters) != len(parameters_dict):
        raise ValueError('Number of parameters and dictionary do not match.')
    if not isinstance(observable, openfermion.QubitOperator):
        raise TypeError('observable must be a QubitOperator, not {}.'
                        .format(type(observable)))

    for val, key in zip(parameters, parameters_dict.keys()):
        parameters_dict[key] = val

    simulated_circuit = simulator.simulate(
        cirq.resolve_parameters(circuit,
                                cirq.ParamResolver(parameters_dict)))
    n_qubits = len(circuit.all_qubits())

    return numpy.real(openfermion.expectation(
        openfermion.get_sparse_operator(observable, n_qubits=n_qubits),
        simulated_circuit.final_state))
